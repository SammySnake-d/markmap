<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Markmap ç®€å•æµ‹è¯•</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #controls {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    button {
      padding: 8px 16px;
      border: 1px solid #5e6ad2;
      background: #5e6ad2;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    button:hover {
      background: #4c5bc7;
    }
    
    #mindmap {
      width: 100%;
      height: 600px;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
    }
    
    #log {
      margin-top: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 8px;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .log-item {
      margin-bottom: 5px;
      padding: 5px;
      border-left: 3px solid #5e6ad2;
      padding-left: 10px;
    }
    
    .log-item.success {
      border-left-color: #28a745;
      background: #d4edda;
    }
    
    .log-item.error {
      border-left-color: #dc3545;
      background: #f8d7da;
    }
  </style>
</head>
<body>
  <h1>ğŸ§ª Markmap ç®€å•æµ‹è¯•</h1>
  
  <div id="controls">
    <button onclick="testBasic()">1. åŸºç¡€æ¸²æŸ“</button>
    <button onclick="testFit()">2. é€‚åº”è§†å›¾</button>
    <button onclick="testRescale()">3. ç¼©æ”¾</button>
    <button onclick="testExpandCollapse()">4. å±•å¼€/æŠ˜å </button>
    <button onclick="testColor()">5. é…è‰²æ–¹æ¡ˆ</button>
    <button onclick="testExport()">6. å¯¼å‡º</button>
    <button onclick="testEvents()">7. äº‹ä»¶ç›‘å¬</button>
    <button onclick="clearLog()">æ¸…é™¤æ—¥å¿—</button>
  </div>
  
  <svg id="mindmap"></svg>
  
  <div id="log"></div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
  <script src="./packages/markmap-lib/dist/browser/index.iife.js"></script>
  <script src="./packages/markmap-view/dist/browser/index.js"></script>
  
  <script>
    let view;
    
    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const item = document.createElement('div');
      item.className = `log-item ${type}`;
      item.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(item);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }
    
    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }
    
    async function testBasic() {
      try {
        log('å¼€å§‹åŸºç¡€æ¸²æŸ“æµ‹è¯•...');
        
        const { Transformer, Markmap } = window.markmap;
        const transformer = new Transformer();
        const { root } = transformer.transform(`
# Markmap æµ‹è¯•
## åŠŸèƒ½æµ‹è¯•
- åŸºç¡€æ¸²æŸ“ âœ…
- è§†å›¾æ§åˆ¶
- èŠ‚ç‚¹æ“ä½œ
## å¯¼å‡ºåŠŸèƒ½
- Markdown å¯¼å‡º
- SVG å¯¼å‡º
## äº‹ä»¶ç³»ç»Ÿ
- ç‚¹å‡»äº‹ä»¶
- å˜æ¢äº‹ä»¶
        `);
        
        const svg = document.querySelector('#mindmap');
        view = Markmap.create(svg, {
          duration: 500,
          maxWidth: 300,
          initialExpandLevel: 3
        });
        
        await view.setData(root);
        await view.fit();
        
        log('âœ… åŸºç¡€æ¸²æŸ“æˆåŠŸï¼', 'success');
      } catch (error) {
        log(`âŒ åŸºç¡€æ¸²æŸ“å¤±è´¥: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    async function testFit() {
      if (!view) {
        log('âŒ è¯·å…ˆè¿è¡ŒåŸºç¡€æ¸²æŸ“æµ‹è¯•', 'error');
        return;
      }
      
      try {
        log('æµ‹è¯• fit()...');
        await view.fit();
        log('âœ… fit() æˆåŠŸ', 'success');
      } catch (error) {
        log(`âŒ fit() å¤±è´¥: ${error.message}`, 'error');
      }
    }
    
    async function testRescale() {
      if (!view) {
        log('âŒ è¯·å…ˆè¿è¡ŒåŸºç¡€æ¸²æŸ“æµ‹è¯•', 'error');
        return;
      }
      
      try {
        log('æµ‹è¯• rescale()...');
        await view.rescale(1.5);
        log('ç¼©æ”¾åˆ° 1.5x');
        await new Promise(r => setTimeout(r, 500));
        await view.rescale(1.0);
        log('âœ… rescale() æˆåŠŸ', 'success');
      } catch (error) {
        log(`âŒ rescale() å¤±è´¥: ${error.message}`, 'error');
      }
    }
    
    async function testExpandCollapse() {
      if (!view || !view.state.data) {
        log('âŒ è¯·å…ˆè¿è¡ŒåŸºç¡€æ¸²æŸ“æµ‹è¯•', 'error');
        return;
      }
      
      try {
        log('æµ‹è¯• expandAll() / collapseAll()...');
        view.expandAll(view.state.data);
        log('å±•å¼€æ‰€æœ‰èŠ‚ç‚¹');
        await new Promise(r => setTimeout(r, 500));
        view.collapseAll(view.state.data);
        log('æŠ˜å æ‰€æœ‰èŠ‚ç‚¹');
        await new Promise(r => setTimeout(r, 500));
        view.expandAll(view.state.data);
        log('âœ… å±•å¼€/æŠ˜å æˆåŠŸ', 'success');
      } catch (error) {
        log(`âŒ å±•å¼€/æŠ˜å å¤±è´¥: ${error.message}`, 'error');
      }
    }
    
    async function testColor() {
      if (!view) {
        log('âŒ è¯·å…ˆè¿è¡ŒåŸºç¡€æ¸²æŸ“æµ‹è¯•', 'error');
        return;
      }
      
      try {
        log('æµ‹è¯• applyColorSchemeWithAnimation()...');
        
        const colorFn = (node) => {
          // å®‰å…¨æ£€æŸ¥
          if (!node) {
            log('è­¦å‘Š: node ä¸º undefinedï¼Œä½¿ç”¨é»˜è®¤é¢œè‰²');
            return '#5e6ad2';
          }
          
          const colors = ['#5e6ad2', '#26b5ce', '#f9c52a', '#f98e52', '#e55e5e'];
          const depth = node.state?.depth ?? node.depth ?? 0;
          return colors[depth % colors.length];
        };
        
        view.applyColorSchemeWithAnimation(colorFn);
        log('âœ… é…è‰²æ–¹æ¡ˆåº”ç”¨æˆåŠŸ', 'success');
      } catch (error) {
        log(`âŒ é…è‰²æ–¹æ¡ˆå¤±è´¥: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    async function testExport() {
      if (!view) {
        log('âŒ è¯·å…ˆè¿è¡ŒåŸºç¡€æ¸²æŸ“æµ‹è¯•', 'error');
        return;
      }
      
      try {
        log('æµ‹è¯•å¯¼å‡ºåŠŸèƒ½...');
        
        const markdown = view.exportAsMarkdown();
        log(`Markdown å¯¼å‡º: ${markdown.length} å­—ç¬¦`);
        
        const svg = view.exportAsSVG();
        log(`SVG å¯¼å‡º: ${svg.length} å­—ç¬¦`);
        
        log('âœ… å¯¼å‡ºåŠŸèƒ½æˆåŠŸ', 'success');
      } catch (error) {
        log(`âŒ å¯¼å‡ºå¤±è´¥: ${error.message}`, 'error');
      }
    }
    
    async function testEvents() {
      if (!view) {
        log('âŒ è¯·å…ˆè¿è¡ŒåŸºç¡€æ¸²æŸ“æµ‹è¯•', 'error');
        return;
      }
      
      try {
        log('æµ‹è¯•äº‹ä»¶ç³»ç»Ÿ...');
        
        const emitter = view.getEventEmitter();
        
        // æµ‹è¯•è‡ªå®šä¹‰äº‹ä»¶
        let eventFired = false;
        emitter.on('test:event', (data) => {
          eventFired = true;
          log(`æ”¶åˆ°æµ‹è¯•äº‹ä»¶: ${data}`);
        });
        
        emitter.emit('test:event', 'Hello from test!');
        
        if (eventFired) {
          log('âœ… äº‹ä»¶ç³»ç»Ÿå·¥ä½œæ­£å¸¸', 'success');
        } else {
          log('âŒ äº‹ä»¶æœªè§¦å‘', 'error');
        }
        
        // ç›‘å¬å®é™…äº‹ä»¶
        emitter.on('node:click', (node) => {
          log(`èŠ‚ç‚¹è¢«ç‚¹å‡»: ${node.content}`);
        });
        
        emitter.on('view:fit', () => {
          log('è§†å›¾é€‚åº”äº‹ä»¶è§¦å‘');
        });
        
        log('å·²è®¾ç½®äº‹ä»¶ç›‘å¬å™¨ï¼Œå°è¯•ç‚¹å‡»èŠ‚ç‚¹æŸ¥çœ‹æ•ˆæœ');
        
      } catch (error) {
        log(`âŒ äº‹ä»¶ç³»ç»Ÿå¤±è´¥: ${error.message}`, 'error');
      }
    }
    
    // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¿è¡ŒåŸºç¡€æµ‹è¯•
    window.addEventListener('load', () => {
      log('é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡æµ‹è¯•');
      setTimeout(() => {
        testBasic();
      }, 500);
    });
  </script>
</body>
</html>
